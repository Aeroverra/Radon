package me.itzsomebody.radon.internal;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;
import me.itzsomebody.radon.config.Config;
import me.itzsomebody.radon.transformers.*;
import me.itzsomebody.radon.utils.*;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

/**
 * Bootstraps and runs the obfuscation process.
 *
 * @author ItzSomebody
 */
public class Bootstrap { // Eyyy bootstrap bill
    /**
     * HashMap that stores all of the loaded classes.
     */
    private Map<String, ClassNode> classPath = new HashMap<>();

    /**
     * HashMap that stores all of the input classes (and as they are obfuscated).
     */
    private Map<String, ClassNode> classes = new HashMap<>();

    /**
     * Extra classes that are generated by the obfuscator.
     */
    private Map<String, ClassNode> extraClasses = new HashMap<>();

    /**
     * Config object
     */
    private Config config;

    /**
     * Input file that read from.
     */
    private File input;

    /**
     * Output file that will be the obfuscation result.
     */
    private File output;

    /**
     * A {@link ZipOutputStream} which we use to write changes to the classes.
     */
    private ZipOutputStream zos;

    /**
     * A HashMap that stores the locations to each of the libraries that will be loaded into
     * the classpath.
     */
    private HashMap<String, File> libs;

    /**
     * Classes that will be protected from obfuscation.
     */
    private List<String> classExempts;

    /**
     * Methods that will be protected from obfuscation.
     */
    private List<String> methodExempts;

    /**
     * Fields that will be protected from obfuscation
     */
    private List<String> fieldExempts;

    /**
     * Transformers that will be used.
     */
    private List<AbstractTransformer> transformers;

    /**
     * Integer that determines how many trash classes to generate if any at all.
     */
    private int trashClasses;

    /**
     * String to be watermarked into the output if any at all.
     */
    private String watermarkMsg;

    /**
     * Integer that determines which watermarking technique to use if any at all.
     */
    private int watermarkType;

    /**
     * String to encrypt {@link Bootstrap#watermarkMsg} if any at all.
     */
    private String watermarkKey;

    /**
     * Strings to write to log.
     */
    private ArrayList<String> logStrings;

    /**
     * {@link Long} used for entry times.
     */
    private long currentTime;

    /**
     * Constructor used for CLI to create a {@link Bootstrap} object.
     *
     * @param config {@link Config} object.
     */
    public Bootstrap(Config config) {
        this.config = config;
    }

    /**
     * Constructor used for GUI to create a {@link Bootstrap} object.
     *
     * @param input         the input {@link File}.
     * @param output        the output {@link File}.
     * @param libs          the {@link HashMap} of libraries.
     * @param classExempts  classes protected from obfuscation as {@link ArrayList}.
     * @param methodExempts methods protected from obfuscation as {@link ArrayList}.
     * @param fieldExempts  fields protected from obfuscation as {@link ArrayList}.
     * @param transformers  transformers that will be run.
     * @param trashClasses  number of trash classes to generate as {@link Integer}.
     * @param watermarkMsg  {@link String} to watermark into the output.
     * @param watermarkType watermark type as {@link Integer}.
     * @param watermarkKey  {@link String} to encrypt watermark message.
     */
    public Bootstrap(
            File input,
            File output,
            HashMap<String, File> libs,
            List<String> classExempts,
            List<String> methodExempts,
            List<String> fieldExempts,
            List<AbstractTransformer> transformers,
            int trashClasses,
            String watermarkMsg,
            int watermarkType,
            String watermarkKey) {
        this.input = input;
        this.output = output;
        this.libs = libs;
        this.classExempts = classExempts;
        this.methodExempts = methodExempts;
        this.fieldExempts = fieldExempts;
        this.transformers = transformers;
        this.trashClasses = trashClasses;
        this.watermarkMsg = watermarkMsg;
        this.watermarkType = watermarkType;
        this.watermarkKey = watermarkKey;
    }

    /**
     * Actual obfuscation starts here.
     *
     * @param doInit should obfuscator read and set variables according to values of {@link Bootstrap#config}?
     * @throws Throwable if any errors are thrown.
     */
    public void startTheParty(boolean doInit) throws Throwable {
        try {
            logStrings = new ArrayList<>();
            if (doInit) {
                init();
                logStrings.add(LoggerUtils.stdOut("Successfully parsed config"));
            } else {
                if (output.exists()) {
                    logStrings.add(LoggerUtils.stdOut("Output already exists, renamed to " + FileUtils.renameExistingFile(output)));
                }
                zos = new ZipOutputStream(new FileOutputStream(output));
            }
            currentTime = System.currentTimeMillis();
            loadClassPath();
            loadInput();

            for (AbstractTransformer transformer : transformers) {
                if (transformer instanceof Renamer) {
                    transformer.init(classes, classPath, classExempts, methodExempts, fieldExempts);
                } else {
                    transformer.init(classes, classExempts, methodExempts, fieldExempts);
                }
                transformer.obfuscate();
                logStrings.addAll(transformer.getLogStrings());
            }

            if (trashClasses != -1) {
                logStrings.add(LoggerUtils.stdOut("------------------------------------------------"));
                for (int i = 0; i < trashClasses; i++) {
                    TrashClasses trashClass = new TrashClasses(StringUtils.randomClassName(classes.keySet()));
                    ClassNode classNode = trashClass.returnTrashClass();
                    extraClasses.put(classNode.name, classNode);
                }
                logStrings.add(LoggerUtils.stdOut("Generated " + String.valueOf(trashClasses) + " trash classes"));
            }

            if (extraClasses.values().size() != 0) {
                logStrings.add(LoggerUtils.stdOut("------------------------------------------------"));
                logStrings.add(LoggerUtils.stdOut("Writing generated classes to output"));

                // Write the contents of extraClasses to zos
                for (ClassNode classNode : extraClasses.values()) {
                    ClassWriter cw = new ClassWriter(0);
                    classNode.accept(cw);

                    ZipEntry newEntry = new ZipEntry(classNode.name + ".class");
                    newEntry.setTime(currentTime);
                    newEntry.setCompressedSize(-1);
                    zos.putNextEntry(newEntry);
                    FileUtils.writeToZip(zos, new ByteArrayInputStream(cw.toByteArray()));
                }
            }

            // Write the contents of classes to zos and recompute maxlocals, maxstack and stackframes
            logStrings.add(LoggerUtils.stdOut("------------------------------------------------"));
            logStrings.add(LoggerUtils.stdOut("Writing classes to output"));
            for (ClassNode classNode : classes.values()) {
                ClassWriter cw = new CustomClassWriter(ClassWriter.COMPUTE_FRAMES);

                if (watermarkMsg != null) {
                    if (watermarkType == 0
                            && NumberUtils.getRandomInt(10) >= 5) {
                        cw.newUTF8("WMID: " + StringUtils.aesEncrypt(watermarkMsg, watermarkKey));
                        logStrings.add(LoggerUtils.stdOut("Watermarking " + watermarkMsg + " into " + classNode.name));
                    } else if (watermarkType == 1
                            && NumberUtils.getRandomInt(10) >= 5) {
                        classNode.signature = StringUtils.aesEncrypt("WMID: " + watermarkMsg, watermarkKey);
                        logStrings.add(LoggerUtils.stdOut("Watermarking " + watermarkMsg + " into " + classNode.name));
                    }
                }

                classNode.accept(cw);

                ZipEntry newEntry = new ZipEntry(classNode.name + ".class");
                newEntry.setTime(currentTime);
                newEntry.setCompressedSize(-1);
                zos.putNextEntry(newEntry);
                FileUtils.writeToZip(zos, new ByteArrayInputStream(cw.toByteArray()));
            }

            logStrings.add(LoggerUtils.stdOut("------------------------------------------------"));
            if (zos != null) {
                zos.setComment("Obfuscation by Radon obfuscator developed by ItzSomebody"); // Cause why not xD
                zos.close();
                logStrings.add(LoggerUtils.stdOut("Finished processing file."));
            }
        } catch (Throwable t) {
            logStrings.add(LoggerUtils.stdOut("Error happened while processing: " + t.getMessage()));
            if (zos != null) {
                zos.close();
            }
            if (output.delete()) {
                logStrings.add(LoggerUtils.stdOut("Deleted output."));
            } else {
                logStrings.add(LoggerUtils.stdOut("Unable to delete faulty output."));
            }

            t.printStackTrace();
            throw new RuntimeException(t.getMessage());
        } finally {
            logStrings.add(LoggerUtils.stdOut("Writing log."));
            LoggerUtils.logWriter(logStrings);
        }
    }

    /**
     * Nice big init method that loads details from the configuration file.
     *
     * @throws RuntimeException if some error pops up while parsing values from {@link Bootstrap#config}.
     */
    private void init() throws RuntimeException {
        try {
            this.config.loadIntoMap();
            this.config.sortExempts();
            this.config.checkConfig();
            this.input = this.config.getInput();
            this.output = this.config.getOutput();
            this.libs = this.config.getLibraries();
            this.classExempts = this.config.getClassExempts();
            this.methodExempts = this.config.getMethodExempts();
            this.fieldExempts = this.config.getFieldExempts();
            this.transformers = new ArrayList<>();
            AbstractTransformer transformer;
            // Specific order of adding transformers, feel free to change if you wish.
            if ((transformer = this.config.getShufflerType()) != null) {
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getInnerClassRemoverType()) != null) {
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getRenamerType()) != null) {
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getNumberObfuscationType()) != null) {
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getInvokeDynamicType()) != null) {
                this.transformers.add(transformer);
            }
            String expireMsg;
            long expireTime;
            if ((expireMsg = this.config.getExpiryMsg()) != null
                    && (expireTime = this.config.getExpiryTime()) != -1) {
                transformer = new Expiry(expireTime, expireMsg);
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getStringEncryptionType()) != null) {
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getFlowObfuscationType()) != null) {
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getStringPoolType()) != null) {
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getLocalVariableObfuscationType()) != null) {
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getLineNumberObfuscationType()) != null) {
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getSourceNameObfuscationType()) != null) {
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getSourceDebugObfuscationType()) != null) {
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getCrasherType()) != null) {
                this.transformers.add(transformer);
            }
            if ((transformer = this.config.getHideCodeType()) != null) {
                this.transformers.add(transformer);
            }
            this.trashClasses = this.config.getTrashClasses();
            this.watermarkMsg = this.config.getWatermarkMsg();
            this.watermarkType = this.config.getWatermarkType();
            this.watermarkKey = this.config.getWatermarkKey();
            if (this.output.exists()) {
                this.logStrings.add(LoggerUtils.stdOut("Output already exists, renamed to " + FileUtils.renameExistingFile(this.output)));
            }
            this.zos = new ZipOutputStream(new FileOutputStream(this.output));
        } catch (Throwable t) {
            throw new RuntimeException("Error while loading config: " + t.getMessage());
        }
    }

    /**
     * Loads library classes into classpath.
     *
     * @throws RuntimeException if library cannot be be opened as Zip or some IOE happens.
     */
    private void loadClassPath() throws RuntimeException {
        ZipFile zipFile;
        Enumeration<? extends ZipEntry> entries;
        ZipEntry zipEntry;
        for (File lib : this.libs.values()) {
            try {
                this.logStrings.add(LoggerUtils.stdOut("Loading library " + lib.getAbsolutePath()));
                zipFile = new ZipFile(lib);
                entries = zipFile.entries();
                while (entries.hasMoreElements()) {
                    zipEntry = entries.nextElement();
                    if (zipEntry.getName().endsWith(".class")) {
                        ClassReader cr = new ClassReader(zipFile.getInputStream(zipEntry));
                        ClassNode classNode = new ClassNode();
                        cr.accept(classNode, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE); // Only need class name

                        this.classPath.put(classNode.name, classNode);
                    }
                }
                zipFile.close();
            } catch (ZipException ze) {
                throw new RuntimeException("There was an error opening " + lib.getAbsolutePath() + " as a zip!");
            } catch (IOException ioe) {
                throw new RuntimeException("Library " + lib.getAbsolutePath() + " does not exist!");
            }
        }
    }

    /**
     * Loads input JAR classes and adds them to {@link Bootstrap#extraClasses} and {@link Bootstrap#classes}.
     *
     * @throws RuntimeException if input cannot be be opened as Zip or some IOE happens.
     */
    private void loadInput() throws RuntimeException {
        ZipFile zipFile;
        Enumeration<? extends ZipEntry> entries;
        ZipEntry zipEntry;
        try {
            this.logStrings.add(LoggerUtils.stdOut("Loading classes of " + this.input.getAbsolutePath()));
            zipFile = new ZipFile(this.input);
            entries = zipFile.entries();
            while (entries.hasMoreElements()) {
                zipEntry = entries.nextElement();
                if (zipEntry.getName().endsWith(".class")) {
                    ClassReader cr = new ClassReader(zipFile.getInputStream(zipEntry));
                    ClassNode classNode = new ClassNode();
                    cr.accept(classNode, ClassReader.SKIP_FRAMES); // We will manually compute stack frames later

                    this.classes.put(classNode.name, classNode);
                } else {
                    ZipEntry newEntry = new ZipEntry(zipEntry);
                    newEntry.setTime(this.currentTime);
                    newEntry.setCompressedSize(-1);
                    this.zos.putNextEntry(newEntry);
                    FileUtils.writeToZip(zos, zipFile.getInputStream(zipEntry));
                }
            }
            zipFile.close();
        } catch (ZipException ze) {
            throw new RuntimeException("There was an error opening " + this.input.getAbsolutePath() + " as a zip!");
        } catch (IOException ioe) {
            throw new RuntimeException("Input " + this.input.getAbsolutePath() + " does not exist!");
        }

        classPath.putAll(classes);
    }

    /**
     * CustomClassWriter that doesn't use the internal Java classpath.
     *
     * @author ItzSomebody
     */
    class CustomClassWriter extends ClassWriter {
        private CustomClassWriter(int flags) {
            super(flags);
        }

        @Override
        protected String getCommonSuperClass(final String type1, final String type2) {
            if (type1.equals("java/lang/Object") || type2.equals("java/lang/Object")) {
                return "java/lang/Object";
            }

            return deriveCommonSuperName(type1, type2);
        }

        /**
         * Attempts to find the common superclass.
         *
         * @param type1 first class name to lookup.
         * @param type2 second class name to lookup.
         * @return the common superclass.
         */
        private String deriveCommonSuperName(String type1, String type2) {
            ClassNode first = returnClazz(type1);
            ClassNode second = returnClazz(type2);

            if (isAssignableFrom(first, second)) {
                return type1;
            }

            if (isAssignableFrom(second, first)) {
                return type2;
            }

            if ((first.access & Opcodes.ACC_INTERFACE) == 0
                    || (second.access & Opcodes.ACC_INTERFACE) == 0) {
                return "java/lang/Object";
            } else {
                do {
                    first = returnClazz(first.superName);
                } while (!isAssignableFrom(first, second));
                return first.name;
            }
        }

        /**
         * Returns the {@link ClassNode} object from {@link Bootstrap#classPath} if it exists.
         *
         * @param ref class name to fetch from {@link Bootstrap#classPath}.
         * @return the {@link ClassNode} object from {@link Bootstrap#classPath} if it exists.
         */
        private ClassNode returnClazz(String ref) {
            ClassNode clazz = classPath.get(ref);
            if (clazz == null) {
                throw new RuntimeException(ref + " does not exist in classpath!");
            }
            return clazz;
        }

        /**
         * Returns true/false based on if clazz1 is the superclass of clazz2.
         *
         * @param clazz1 possible superclass.
         * @param clazz2 class to check if assignable from clazz1.
         * @return true/false based on if clazz1 is the superclass of clazz2.
         */
        private boolean isAssignableFrom(ClassNode clazz1, ClassNode clazz2) {
            return (clazz1.name.equals("java/lang/Object") || clazz1.superName.equals(clazz2.name));
        }
    }
}
