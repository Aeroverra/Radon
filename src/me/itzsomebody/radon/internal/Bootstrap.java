package me.itzsomebody.radon.internal;

import me.itzsomebody.radon.asm.ClassReader;
import me.itzsomebody.radon.asm.ClassWriter;
import me.itzsomebody.radon.asm.Opcodes;
import me.itzsomebody.radon.asm.commons.ClassRemapper;
import me.itzsomebody.radon.asm.commons.SimpleRemapper;
import me.itzsomebody.radon.asm.tree.ClassNode;
import me.itzsomebody.radon.asm.tree.FieldNode;
import me.itzsomebody.radon.asm.tree.MethodNode;
import me.itzsomebody.radon.classes.EmptyClass;
import me.itzsomebody.radon.config.Config;
import me.itzsomebody.radon.methods.InvokeDynamicBSM;
import me.itzsomebody.radon.methods.StringEncryption;
import me.itzsomebody.radon.transformers.*;
import me.itzsomebody.radon.transformers.flow.LightFlowObfuscation;
import me.itzsomebody.radon.transformers.flow.NormalFlowObfuscation;
import me.itzsomebody.radon.transformers.invokedynamic.LightInvokeDynamic;
import me.itzsomebody.radon.transformers.invokedynamic.NormalInvokeDynamic;
import me.itzsomebody.radon.transformers.linenumbers.ObfuscateLineNumbers;
import me.itzsomebody.radon.transformers.linenumbers.RemoveLineNumbers;
import me.itzsomebody.radon.transformers.localvariables.ObfuscateLocalVariables;
import me.itzsomebody.radon.transformers.localvariables.RemoveLocalVariables;
import me.itzsomebody.radon.transformers.sourcename.ObfuscateSourceName;
import me.itzsomebody.radon.transformers.sourcename.RemoveSourceName;
import me.itzsomebody.radon.transformers.stringencryption.LightStringEncryption;
import me.itzsomebody.radon.transformers.stringencryption.NormalStringEncryption;
import me.itzsomebody.radon.utils.*;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

/**
 * Bootstraps and runs the obfuscation process.
 *
 * @author ItzSomebody
 */
public class Bootstrap { // Eyyy bootstrap bill
    /**
     * HashMap that stores all of the loaded classes.
     */
    private HashMap<String, ClassNode> classPath = new HashMap<>();

    /**
     * HashMap that stores all of the input classes (and as they are obfuscated).
     */
    private HashMap<String, ClassNode> classes = new HashMap<>();

    /**
     * Extra classes that are generated by the obfuscator.
     */
    private HashMap<String, ClassNode> extraClasses = new HashMap<>();

    /**
     * Used for class, method and field renamming. Format is oldName -> newName.
     */
    private HashMap<String, String> mappings = new HashMap<>();

    /**
     * Config object
     */
    private Config config;

    /**
     * Input file that read from.
     */
    private File input;

    /**
     * Output file that will be the obfuscation result.
     */
    private File output;

    /**
     * A {@link ZipOutputStream} which we use to write changes to the classes.
     */
    private ZipOutputStream zos;

    /**
     * A HashMap that stores the locations to each of the libraries that will be loaded into
     * the classpath.
     */
    private HashMap<String, File> libs;

    /**
     * Classes that will be protected from obfuscation.
     */
    private ArrayList<String> classExempts;

    /**
     * Methods that will be protected from obfuscation.
     */
    private ArrayList<String> methodExempts;

    /**
     * Fields that will be protected from obfuscation
     */
    private ArrayList<String> fieldExempts;

    /**
     * Integer that determines which kind of string encryption to apply if any at all.
     */
    private int stringEncryptionType;

    /**
     * Integer that determines which kind of invokedynamic to apply if any at all.
     */
    private int invokeDynamicType;

    /**
     * Integer that determines which kind of flow obfuscation to apply if any at all.
     */
    private int flowObfuscationType;

    /**
     * Integer that determines which kind of local variable obfuscation to apply if any at all.
     */
    private int localVariableType;

    /**
     * Integer that determines which kind of line number obfuscation to apply if any at all.
     */
    private int lineNumberType;

    /**
     * Integer that determines which kind of source name obfuscation to apply if any at all.
     */
    private int sourceNameType;

    /**
     * Integer that determines if the obfuscator should apply a decompiler crashing technique.
     */
    private int crasherType;

    /**
     * Integer that determines if the obfuscator should apply synthetic modifiers.
     */
    private int hideCodeType;

    /**
     * Integer that determines if the obfuscator should apply number obfuscator.
     */
    private int numberObfuscationType;

    /**
     * Integer that determines if the obfuscator should pool strings into a method.
     */
    private int stringPoolType;

    /**
     * Integer that determines if the obfuscator should apply a decompiler crashing technique.
     */
    private int renamerType;

    /**
     * Boolean that determines if the obfuscator should consider the input as a Spigot/Bukkit/Bungee plugin.
     */
    private boolean spigotMode;

    /**
     * Integer that determines how many trash classes to generate if any at all.
     */
    private int trashClasses;

    /**
     * String to be watermarked into the output if any at all.
     */
    private String watermarkMsg;

    /**
     * Integer that determines which watermarking technique to use if any at all.
     */
    private int watermarkType;

    /**
     * String to encrypt {@link Bootstrap#watermarkMsg} if any at all.
     */
    private String watermarkKey;

    /**
     * Strings to write to log.
     */
    private ArrayList<String> logStrings;

    /**
     * {@link Long} used for entry times.
     */
    private long currentTime;

    /**
     * Constructor used for CLI to create a {@link Bootstrap} object.
     *
     * @param config {@link Config} object.
     */
    public Bootstrap(Config config) {
        this.config = config;
    }

    /**
     * Constructor used for GUI to create a {@link Bootstrap} object.
     *
     * @param input                 the input {@link File}.
     * @param output                the output {@link File}.
     * @param libs                  the {@link HashMap} of libraries.
     * @param classExempts          classes protected from obfuscation as {@link ArrayList}.
     * @param methodExempts         methods protected from obfuscation as {@link ArrayList}.
     * @param fieldExempts          fields protected from obfuscation as {@link ArrayList}.
     * @param stringEncryptionType  string encryption type as {@link Integer}.
     * @param invokeDynamicType     invokedynamic obfuscation type as {@link Integer}.
     * @param flowObfuscationType   flow obfuscation type as {@link Integer}.
     * @param localVariableType     local variable obfuscation type as {@link Integer}.
     * @param lineNumberType        line number obfuscation type as {@link Integer}.
     * @param sourceNameType        source name obfuscation type as {@link Integer}.
     * @param crasherType           crasher type as {@link Integer}.
     * @param hideCodeType          hidecode type as {@link Integer}.
     * @param numberObfuscationType number obfuscation type as {@link Integer}.
     * @param stringPoolType        string pool type as {@link Integer}.
     * @param renamerType           renaming type as {@link Integer}.
     * @param spigotMode            states if plugin be considered a Spigot/Bukkit/Bungee plugin as {@link Boolean}.
     * @param trashClasses          number of trash classes to generate as {@link Integer}.
     * @param watermarkMsg          {@link String} to watermark into the output.
     * @param watermarkType         watermark type as {@link Integer}.
     * @param watermarkKey          {@link String} to encrypt watermark message.
     */
    public Bootstrap(
            File input,
            File output,
            HashMap<String, File> libs,
            ArrayList<String> classExempts,
            ArrayList<String> methodExempts,
            ArrayList<String> fieldExempts,
            int stringEncryptionType,
            int invokeDynamicType,
            int flowObfuscationType,
            int localVariableType,
            int lineNumberType,
            int sourceNameType,
            int crasherType,
            int hideCodeType,
            int numberObfuscationType,
            int stringPoolType,
            int renamerType,
            boolean spigotMode,
            int trashClasses,
            String watermarkMsg,
            int watermarkType,
            String watermarkKey) {
        this.input = input;
        this.output = output;
        this.libs = libs;
        this.classExempts = classExempts;
        this.methodExempts = methodExempts;
        this.fieldExempts = fieldExempts;
        this.stringEncryptionType = stringEncryptionType;
        this.invokeDynamicType = invokeDynamicType;
        this.flowObfuscationType = flowObfuscationType;
        this.localVariableType = localVariableType;
        this.lineNumberType = lineNumberType;
        this.sourceNameType = sourceNameType;
        this.crasherType = crasherType;
        this.hideCodeType = hideCodeType;
        this.numberObfuscationType = numberObfuscationType;
        this.stringPoolType = stringPoolType;
        this.numberObfuscationType = numberObfuscationType;
        this.stringPoolType = stringPoolType;
        this.renamerType = renamerType;
        this.spigotMode = spigotMode;
        this.trashClasses = trashClasses;
        this.watermarkMsg = watermarkMsg;
        this.watermarkType = watermarkType;
        this.watermarkKey = watermarkKey;
    }

    /**
     * Actual obfuscation starts here.
     *
     * @param doInit should obfuscator read and set variables according to values of {@link Bootstrap#config}?
     * @throws Throwable if any errors are thrown.
     */
    public void startTheParty(boolean doInit) throws Throwable {
        try {
            logStrings = new ArrayList<>();
            if (doInit) {
                init();
                logStrings.add(LoggerUtils.stdOut("Successfully parsed config"));
            } else {
                if (output.exists()) {
                    logStrings.add(LoggerUtils.stdOut("Output already exists, renamed to " + FileUtils.renameExistingFile(output)));
                }
                zos = new ZipOutputStream(new FileOutputStream(output));
            }
            currentTime = System.currentTimeMillis();
            loadClassPath();
            loadInput();

            // 0 = true; -1 = false
            if (renamerType == 0) {
                ArrayList<ClassNode> classesAsList = new ArrayList<>();
                for (ClassNode classNode : classes.values()) { // Remapping time
                    for (MethodNode methodNode : classNode.methods) {
                        if (BytecodeUtils.hasSameMethod(methodNode, classNode, classPath)
                                || methodNode.name.startsWith("<")
                                || (methodNode.access & Opcodes.ACC_NATIVE) != 0
                                || methodExempts.contains(classNode.name + "." + methodNode.name + methodNode.desc)
                                || methodNode.name.equals("main")
                                || methodNode.name.equals("premain")) continue;
                        String key = classNode.name + "." + methodNode.name + methodNode.desc;
                        mappings.put(key, StringUtils.crazyString());
                        logStrings.add(LoggerUtils.stdOut("Generated mapping for " + key));
                    }

                    /*if (classNode.fields != null) {
                        for (FieldNode fieldNode : classNode.fields) {
                            if (fieldExempts.contains(classNode.name + "." + fieldNode.name)) continue;
                            String key = classNode.name + "." + fieldNode.name;
                            mappings.put(key, StringUtils.crazyString());
                            logStrings.add(LoggerUtils.stdOut("Generated mapping " + key));
                        }
                    }*/
                    // TODO: Fix this stupid thing ^^^
                    // Some fields are not properly remapped

                    if (!BytecodeUtils.isMain(classNode, spigotMode)
                            && !classExempts.contains(classNode.name)) {
                    /*String renamedStuff = "";
                    String[] splitName = classNode.name.split("/");
                    for (int j = 0; j < splitName.length - 1; j++) {
                        if (j == 0) {
                            //renamedStuff = renamedStuff + splitName[j];
                            renamedStuff = renamedStuff + StringUtils.crazyString();
                        } else {
                            //renamedStuff = renamedStuff + "/" + splitName[j];
                            renamedStuff = renamedStuff + "/" + StringUtils.crazyString();
                        }
                    }
                    renamedStuff = renamedStuff + "/" + StringUtils.crazyString();*/
                        // ^^^ This makes file size huge ^^^
                        mappings.put(classNode.name, StringUtils.crazyString());
                        logStrings.add(LoggerUtils.stdOut("Generated mapping for " + classNode.name));
                    }
                    classesAsList.add(classNode);
                }

                // Apply mapping
                SimpleRemapper simpleRemapper = new SimpleRemapper(mappings);
                for (ClassNode classNode : classesAsList) {
                    ClassNode copy = new ClassNode();
                    classNode.accept(new ClassRemapper(copy, simpleRemapper));
                    Collections.shuffle(classNode.methods);
                    Collections.shuffle(classNode.fields);
                    copy.access = BytecodeUtils.accessFixer(copy.access);
                    for (MethodNode methodNode : copy.methods) {
                        methodNode.access = BytecodeUtils.accessFixer(methodNode.access);
                    }

                    if (copy.fields != null) {
                        for (FieldNode fieldNode : copy.fields) {
                            fieldNode.access = BytecodeUtils.accessFixer(fieldNode.access);
                        }
                    }

                    classes.remove(classNode.name);
                    classes.put(copy.name, copy);
                    classPath.put(copy.name, copy);
                    logStrings.add(LoggerUtils.stdOut("Applied mapping to " + classNode.name));
                }
            }

            String decryptionMethodPath = null; // Just to make IntelliJ shut up about "Might not have been initialized"
            String bsmMethodPath = null; // ^^^

            // Creates a class if string encryption or invokedynamic obfuscation are enabled.
            // Maybe add String Pool to this as well.
            if (stringEncryptionType != -1
                    || invokeDynamicType != -1) {
                /*
                ArrayList<String> allClasses = new ArrayList<>();
                for (ClassNode cn : classes.values()) {
                    allClasses.add(cn.name);
                }
                String randomClass = allClasses.get(MiscUtils.getRandomInt(allClasses.size()));
                String newClass = randomClass + "$" + StringUtils.crazyString();
                */
                String newClass = StringUtils.crazyString();
                ClassNode classNode = EmptyClass.emptyClass(newClass);
                String decryptionMethodName = StringUtils.crazyString();
                decryptionMethodPath = newClass + "." + decryptionMethodName;

                String bsmMethodName = StringUtils.crazyString();
                bsmMethodPath = newClass + "." + bsmMethodName;

                if (stringEncryptionType == 0) { // Light
                    classNode.methods.add(StringEncryption.lightMethod(decryptionMethodName));
                } else if (stringEncryptionType == 1) { // Normal
                    classNode.methods.add(StringEncryption.normalMethod(decryptionMethodName));
                }

                if (invokeDynamicType == 0) { // Light
                    classNode.methods.add(InvokeDynamicBSM.lightBSM(bsmMethodPath));
                } else if (invokeDynamicType == 1) { // Normal
                    classNode.methods.add(InvokeDynamicBSM.normalBSM(bsmMethodPath));
                }

                classNode.signature = StringUtils.crazyString();
                extraClasses.put(classNode.name, classNode);
            }

            /*
             * Specific order. Feel free to change if you wish
             */
            for (ClassNode classNode : classes.values()) {
                if (classNode.name.contains("$")) {
                    String[] splitName = classNode.name.split("\\$");

                    if (classExempts.contains(splitName[0])) {
                        continue;
                    }
                } else {
                    if (classExempts.contains(classNode.name)) {
                        continue;
                    }
                }
                logStrings.add(LoggerUtils.stdOut("------------------------------------------------"));
                logStrings.add(LoggerUtils.stdOut("Processing " + classNode.name));
                if (stringEncryptionType == 0) {
                    LightStringEncryption lightStringEncryption = new LightStringEncryption(classNode, decryptionMethodPath, spigotMode, methodExempts);
                    logStrings.addAll(lightStringEncryption.getLogStrings());
                } else if (stringEncryptionType == 1) {
                    NormalStringEncryption normalStringEncryption = new NormalStringEncryption(classNode, decryptionMethodPath, spigotMode, methodExempts);
                    logStrings.addAll(normalStringEncryption.getLogStrings());
                }

                if (stringPoolType == 0) {
                    StringPool stringPool = new StringPool(classNode, methodExempts);
                    logStrings.addAll(stringPool.getLogStrings());
                }

                if (flowObfuscationType == 0) {
                    LightFlowObfuscation lightFlowObfuscation = new LightFlowObfuscation(classNode, methodExempts);
                    logStrings.addAll(lightFlowObfuscation.getLogStrings());
                } else if (flowObfuscationType == 1) {
                    NormalFlowObfuscation normalFlowObfuscation = new NormalFlowObfuscation(classNode, methodExempts);
                    logStrings.addAll(normalFlowObfuscation.getLogStrings());
                }

                if (invokeDynamicType == 0) {
                    LightInvokeDynamic lightInvokeDynamic = new LightInvokeDynamic(classNode, bsmMethodPath, spigotMode, methodExempts);
                    logStrings.addAll(lightInvokeDynamic.getLogStrings());
                } else if (invokeDynamicType == 1) {
                    NormalInvokeDynamic normalInvokeDynamic = new NormalInvokeDynamic(classNode, bsmMethodPath, spigotMode, methodExempts);
                    logStrings.addAll(normalInvokeDynamic.getLogStrings());
                }

                if (localVariableType == 0) {
                    ObfuscateLocalVariables obfuscateLocalVariables = new ObfuscateLocalVariables(classNode, methodExempts);
                    logStrings.addAll(obfuscateLocalVariables.getLogStrings());
                } else if (localVariableType == 1) {
                    RemoveLocalVariables removeLocalVariables = new RemoveLocalVariables(classNode, methodExempts);
                    logStrings.addAll(removeLocalVariables.getLogStrings());
                }

                if (lineNumberType == 0) {
                    ObfuscateLineNumbers obfuscateLineNumbers = new ObfuscateLineNumbers(classNode, methodExempts);
                    logStrings.addAll(obfuscateLineNumbers.getLogStrings());
                } else if (lineNumberType == 1) {
                    RemoveLineNumbers removeLineNumbers = new RemoveLineNumbers(classNode, methodExempts);
                    logStrings.addAll(removeLineNumbers.getLogStrings());
                }

                if (sourceNameType == 0) {
                    ObfuscateSourceName obfuscateSourceName = new ObfuscateSourceName(classNode);
                    logStrings.addAll(obfuscateSourceName.getLogStrings());
                } else if (sourceNameType == 1) {
                    RemoveSourceName removeSourceName = new RemoveSourceName(classNode);
                    logStrings.addAll(removeSourceName.getLogStrings());
                }

                if (crasherType == 0) {
                    Crasher crasher = new Crasher(classNode);
                    logStrings.addAll(crasher.getLogStrings());
                }

                if (hideCodeType == 0) {
                    HideCode hideCode = new HideCode(classNode, spigotMode, methodExempts, fieldExempts);
                    logStrings.addAll(hideCode.getLogStrings());
                }

                if (numberObfuscationType == 0) {
                    NumberObfuscation numberObfuscation = new NumberObfuscation(classNode, methodExempts);
                    logStrings.addAll(numberObfuscation.getLogStrings());
                }
            }

            if (trashClasses != -1) {
                logStrings.add(LoggerUtils.stdOut("------------------------------------------------"));
                for (int i = 0; i < trashClasses; i++) {
                    TrashClasses trashClass = new TrashClasses(StringUtils.crazyString());
                    ClassNode classNode = trashClass.returnTrashClass();
                    extraClasses.put(classNode.name, classNode);
                }
                logStrings.add(LoggerUtils.stdOut("Generated " + String.valueOf(trashClasses) + " trash classes"));
            }

            if (extraClasses.values().size() != 0) {
                logStrings.add(LoggerUtils.stdOut("------------------------------------------------"));
                logStrings.add(LoggerUtils.stdOut("Writing generated classes to output"));

                // Write the contents of extraClasses to zos
                for (ClassNode classNode : extraClasses.values()) {
                    ClassWriter cw = new ClassWriter(0);
                    classNode.accept(cw);

                    ZipEntry newEntry = new ZipEntry(classNode.name + ".class");
                    newEntry.setTime(currentTime);
                    newEntry.setCompressedSize(-1);
                    zos.putNextEntry(newEntry);
                    FileUtils.writeToZip(zos, new ByteArrayInputStream(cw.toByteArray()));
                }
            }

            // Write the contents of classes to zos and recompute maxlocals, maxstack and stackframes
            logStrings.add(LoggerUtils.stdOut("------------------------------------------------"));
            logStrings.add(LoggerUtils.stdOut("Writing classes to output"));
            for (ClassNode classNode : classes.values()) {
                ClassWriter cw;
                if (classExempts.contains(classNode.name)) {
                    cw = new ClassWriter(0);
                } else {
                    cw = new CustomClassWriter(ClassWriter.COMPUTE_FRAMES);
                }

                if (watermarkMsg != null) {
                    if (watermarkType == 0
                            && MiscUtils.getRandomInt(10) >= 5) {
                        cw.newUTF8("WMID: " + StringUtils.aesEncrypt(watermarkMsg, watermarkKey));
                        logStrings.add(LoggerUtils.stdOut("Watermarking " + watermarkMsg + " into " + classNode.name));
                    } else if (watermarkType == 1
                            && MiscUtils.getRandomInt(10) >= 5) {
                        classNode.signature = StringUtils.aesEncrypt("WMID: " + watermarkMsg, watermarkKey);
                        logStrings.add(LoggerUtils.stdOut("Watermarking " + watermarkMsg + " into " + classNode.name));
                    }
                }

                classNode.accept(cw);

                ZipEntry newEntry = new ZipEntry(classNode.name + ".class");
                newEntry.setTime(currentTime);
                newEntry.setCompressedSize(-1);
                zos.putNextEntry(newEntry);
                FileUtils.writeToZip(zos, new ByteArrayInputStream(cw.toByteArray()));
            }

            logStrings.add(LoggerUtils.stdOut("------------------------------------------------"));
            if (zos != null) {
                zos.setComment("Obfuscation by Radon obfuscator developed by ItzSomebody"); // Cause why not xD
                zos.close();
                logStrings.add(LoggerUtils.stdOut("Finished processing file."));
            }
        } catch (Throwable t) {
            logStrings.add(LoggerUtils.stdOut("Error happened while processing: " + t.getMessage()));
            if (zos != null) {
                zos.close();
            }
            output.delete();
            logStrings.add(LoggerUtils.stdOut("Deleted output."));
            throw new RuntimeException(t.getMessage());
        } finally {
            logStrings.add(LoggerUtils.stdOut("Writing log."));
            LoggerUtils.logWriter(logStrings);
        }
    }

    /**
     * Nice big init method that loads details from the configuration file.
     *
     * @throws RuntimeException if some error pops up while parsing values from {@link Bootstrap#config}.
     */
    private void init() throws RuntimeException {
        try {
            config.loadIntoMap();
            config.sortExempts();
            config.checkConfig();
            input = config.getInput();
            output = config.getOutput();
            libs = config.getLibraries();
            classExempts = config.getClassExempts();
            methodExempts = config.getMethodExempts();
            fieldExempts = config.getFieldExempts();
            stringEncryptionType = config.getStringEncryptionType();
            invokeDynamicType = config.getInvokeDynamicType();
            flowObfuscationType = config.getFlowObfuscationType();
            localVariableType = config.getLocalVariableObfuscationType();
            lineNumberType = config.getLineNumberObfuscationType();
            sourceNameType = config.getSourceNameObfuscationType();
            crasherType = config.getCrasherType();
            hideCodeType = config.getHideCodeType();
            numberObfuscationType = config.getNumberObfuscationType();
            stringPoolType = config.getStringPoolType();
            renamerType = config.getRenamerType();
            spigotMode = config.getSpigotBool();
            trashClasses = config.getTrashClasses();
            watermarkMsg = config.getWatermarkMsg();
            watermarkType = config.getWatermarkType();
            watermarkKey = config.getWatermarkKey();
            if (output.exists()) {
                logStrings.add(LoggerUtils.stdOut("Output already exists, renamed to " + FileUtils.renameExistingFile(output)));
            }
            zos = new ZipOutputStream(new FileOutputStream(output));
        } catch (Throwable t) {
            throw new RuntimeException("Error while loading config: " + t.getMessage());
        }
    }

    /**
     * Loads library classes into classpath.
     *
     * @throws RuntimeException if library cannot be be opened as Zip or some IOE happens.
     */
    private void loadClassPath() throws RuntimeException {
        ZipFile zipFile;
        Enumeration<? extends ZipEntry> entries;
        ZipEntry zipEntry;
        for (File lib : libs.values()) {
            try {
                logStrings.add(LoggerUtils.stdOut("Loading library " + lib.getAbsolutePath()));
                zipFile = new ZipFile(lib);
                entries = zipFile.entries();
                while (entries.hasMoreElements()) {
                    zipEntry = entries.nextElement();
                    if (zipEntry.getName().endsWith(".class")) {
                        ClassReader cr = new ClassReader(zipFile.getInputStream(zipEntry));
                        ClassNode classNode = new ClassNode();
                        cr.accept(classNode, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE); // Only need class name

                        classPath.put(classNode.name, classNode);
                    }
                }
                zipFile.close();
            } catch (ZipException ze) {
                throw new RuntimeException("There was an error opening " + lib.getAbsolutePath() + " as a zip!");
            } catch (IOException ioe) {
                throw new RuntimeException("Library " + lib.getAbsolutePath() + " does not exist!");
            }
        }
    }

    /**
     * Loads input JAR classes and adds them to {@link Bootstrap#extraClasses} and {@link Bootstrap#classes}.
     *
     * @throws RuntimeException if input cannot be be opened as Zip or some IOE happens.
     */
    private void loadInput() throws RuntimeException {
        ZipFile zipFile;
        Enumeration<? extends ZipEntry> entries;
        ZipEntry zipEntry;
        try {
            logStrings.add(LoggerUtils.stdOut("Loading classes of " + input.getAbsolutePath()));
            zipFile = new ZipFile(input);
            entries = zipFile.entries();
            while (entries.hasMoreElements()) {
                zipEntry = entries.nextElement();
                if (zipEntry.getName().endsWith(".class")) {
                    ClassReader cr = new ClassReader(zipFile.getInputStream(zipEntry));
                    ClassNode classNode = new ClassNode();
                    cr.accept(classNode, ClassReader.SKIP_FRAMES); // We will manually compute stack frames later

                    classes.put(classNode.name, classNode);
                } else {
                    ZipEntry newEntry = new ZipEntry(zipEntry);
                    newEntry.setTime(currentTime);
                    zos.putNextEntry(newEntry);
                    FileUtils.writeToZip(zos, zipFile.getInputStream(zipEntry));
                }
            }
            zipFile.close();
        } catch (ZipException ze) {
            throw new RuntimeException("There was an error opening " + input.getAbsolutePath() + " as a zip!");
        } catch (IOException ioe) {
            throw new RuntimeException("Input " + input.getAbsolutePath() + " does not exist!");
        }

        classPath.putAll(classes);
    }

    /**
     * CustomClassWriter that doesn't use the internal Java classpath.
     *
     * @author ItzSomebody
     */
    class CustomClassWriter extends ClassWriter {
        public CustomClassWriter(int flags) {
            super(flags);
        }

        @Override
        protected String getCommonSuperClass(final String type1, final String type2) {
            if (type1.equals("java/lang/Object") || type2.equals("java/lang/Object")) {
                return "java/lang/Object";
            }

            return deriveCommonSuperName(type1, type2);
        }

        /**
         * Attempts to find the common superclass.
         *
         * @param type1 first class name to lookup.
         * @param type2 second class name to lookup.
         * @return the common superclass.
         */
        private String deriveCommonSuperName(String type1, String type2) {
            ClassNode first = returnClazz(type1);
            ClassNode second = returnClazz(type2);

            if (isAssignableFrom(first, second)) {
                return type1;
            }

            if (isAssignableFrom(second, first)) {
                return type2;
            }

            if ((first.access & Opcodes.ACC_INTERFACE) == 0
                    || (second.access & Opcodes.ACC_INTERFACE) == 0) {
                return "java/lang/Object";
            } else {
                do {
                    first = returnClazz(first.superName);
                } while (!isAssignableFrom(first, second));
                return first.name;
            }
        }

        /**
         * Returns the {@link ClassNode} object from {@link Bootstrap#classPath} if it exists.
         *
         * @param ref class name to fetch from {@link Bootstrap#classPath}.
         * @return the {@link ClassNode} object from {@link Bootstrap#classPath} if it exists.
         */
        private ClassNode returnClazz(String ref) {
            ClassNode clazz = classPath.get(ref);
            if (clazz == null) {
                throw new RuntimeException(ref + " does not exist in classpath!");
            }
            return clazz;
        }

        /**
         * Returns true/false based on if clazz1 is the superclass of clazz2.
         *
         * @param clazz1 possible superclass.
         * @param clazz2 class to check if assignable from clazz1.
         * @return true/false based on if clazz1 is the superclass of clazz2.
         */
        private boolean isAssignableFrom(ClassNode clazz1, ClassNode clazz2) {
            if (clazz1.name.equals("java/lang/Object")) {
                // java/lang/Object has no superclass so checking for superclass = null
                return true;
            }
            if (clazz1.superName.equals(clazz2.name)) {
                return true;
            }
            return false;
        }
    }
}
